<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>LibSVF by castl</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>LibSVF</h1>
        <h2>A library to compute Side-channel Vulnerability Factor</h2>

        <section id="downloads">
          <a href="https://github.com/castl/libsvf/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/castl/libsvf/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/castl/libsvf" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>LibSVF -- A Library for computing SVF</h1>

<p>Library to help in computing Side-channel Vulnerability Factor, a
metric defined in "Side-channel Vulnerability Factor: A Metric for
Measuring Information Leakage", published in ISCA 2012.</p>

<p><a href="http://www.cs.columbia.edu/%7Esimha/preprint_isca12_svf.pdf">http://www.cs.columbia.edu/~simha/preprint_isca12_svf.pdf</a></p>

<h1>Compilation</h1>

<p>Compilation is not necessary. LibSVF is nearly all templates, so it
is contained entirely in header files. You can compile and run the
unit tests with scons.</p>

<h1>Usage</h1>

<p>Usage examples for libsvf can be found in tests/*.cpp. As a small
example, here is a very basic usage using scalars as the data
collection points:</p>

<div class="highlight">
<pre><span class="cp">#include &lt;svf/svf.hpp&gt;</span>

<span class="k">struct</span> <span class="n">ScalarDist</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">double</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">fabs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// The first two specify the oracle data type and distance function.</span>
<span class="c1">// The last two are the same but for the side-channel trace.</span>
<span class="n">SVF</span><span class="o">::</span><span class="n">SVF</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">ScalarDist</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ScalarDist</span><span class="o">&gt;</span> <span class="n">svf</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">svf</span><span class="p">.</span><span class="n">pushTimestep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">svfVal</span> <span class="o">=</span> <span class="n">svf</span><span class="p">.</span><span class="n">computeSVF</span><span class="p">();</span>
<span class="c1">// This will be 1.0 since points are the same</span>
</pre>
</div>


<p>Here's an example of sparse vectors and doubles as data points. In
this example, the "attacker" can see only the length of the oracle
vector, but there is still some correlation:</p>

<div class="highlight">
<pre><span class="cp">#include &lt;svf/svf.hpp&gt;</span>
<span class="cp">#include &lt;svf/sparse_vector.hpp&gt;</span>

<span class="k">struct</span> <span class="n">ScalarDist</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">double</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">fbs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="n">SVF</span><span class="o">::</span><span class="n">SVF</span><span class="o">&lt;</span><span class="n">SVF</span><span class="o">::</span><span class="n">SparseVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SVF</span><span class="o">::</span><span class="n">SparseVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">EuclideanDistance</span><span class="o">&lt;&gt;</span><span class="p">,</span>
         <span class="kt">double</span><span class="p">,</span> <span class="n">ScalarDist</span><span class="o">&gt;</span> <span class="n">svf</span><span class="p">;</span> 

<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Just the length seems a decent approximation for 6</span>
    <span class="c1">// dimensions</span>
    <span class="n">SVF</span><span class="o">::</span><span class="n">SparseVector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">randVec</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">svf</span><span class="p">.</span><span class="n">pushTimestep</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">svfVal</span> <span class="o">=</span> <span class="n">svf</span><span class="p">.</span><span class="n">computeSVF</span><span class="p">();</span>
<span class="c1">// This will be between 0 and 1</span>
</pre>
</div>


<h1>Documentation</h1>

<p>Yeah, right! Read the code and the unit tests.</p>

<h1>Credits</h1>

<p>SVF research is conducted at the Computer Architecture and Security
Technologies Lab in the Computer Science department at Columbia
University in the city of New York. The original inventors of SVF
are John Demme, Robert Martin, Adam Waksman and Simha Sethumadhavan.
Their work is/was supported by grants FA 99500910389 (AFOSR), FA
865011C7190 (DARPA), FA 87501020253 (DARPA), CCF/TC 1054844 (NSF)
and gifts from Microsoft Research, WindRiver Corp, Xilinx and
Synopsys Inc. Opinions, findings, conclusions and recommendations
expressed in this material are those of the authors and do not
necessarily reflect the views of the US Government or commercial
entities.</p>

<p>LibSVF code written and occasionally maintained by John Demme
<a href="mailto:jdd@cs.columbia.edu">jdd@cs.columbia.edu</a>.</p>
      </section>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33463980-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>