{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-33463980-1","body":"LibSVF -- A Library for computing SVF\r\n======\r\n\r\nLibrary to help in computing Side-channel Vulnerability Factor, a\r\nmetric defined in \"Side-channel Vulnerability Factor: A Metric for\r\nMeasuring Information Leakage\", published in ISCA 2012.\r\n\r\nhttp://www.cs.columbia.edu/~simha/preprint_isca12_svf.pdf\r\n\r\nCompilation\r\n=====\r\nCompilation is not necessary. LibSVF is nearly all templates, so it\r\nis contained entirely in header files. You can compile and run the\r\nunit tests with scons.\r\n\r\nUsage\r\n======\r\nUsage examples for libsvf can be found in tests/*.cpp. As a small\r\nexample, here is a very basic usage using scalars as the data\r\ncollection points:\r\n\r\n```c++\r\n#include <svf/svf.hpp>\r\n\r\nstruct ScalarDist {\r\n    template <typename T>\r\n    double operator()(T a, T b) {\r\n        assert(!isnan(a));\r\n        assert(!isnan(b));\r\n        return fabs(a - b);\r\n    }\r\n};\r\n\r\n// The first two specify the oracle data type and distance function.\r\n// The last two are the same but for the side-channel trace.\r\nSVF::SVF<int, ScalarDist, int, ScalarDist> svf;\r\n\r\nfor (size_t i=0; i<1000; i++) {\r\n    svf.pushTimestep(i, i);\r\n}\r\n\r\ndouble svfVal = svf.computeSVF();\r\n// This will be 1.0 since points are the same\r\n```\r\n\r\n\r\nHere's an example of sparse vectors and doubles as data points. In\r\nthis example, the \"attacker\" can see only the length of the oracle\r\nvector, but there is still some correlation:\r\n```c++\r\n#include <svf/svf.hpp>\r\n#include <svf/sparse_vector.hpp>\r\n\r\nstruct ScalarDist {\r\n    template <typename T>\r\n    double operator()(T a, T b) {\r\n        assert(!isnan(a));\r\n        assert(!isnan(b));\r\n        return fbs(a - b);\r\n    }\r\n};\r\n\r\n// ...\r\n\r\nSVF::SVF<SVF::SparseVector<double>, SVF::SparseVector<double>::EuclideanDistance<>,\r\n         double, ScalarDist> svf; \r\n\r\nfor (size_t i=0; i<100; i++) {\r\n    // Just the length seems a decent approximation for 6\r\n    // dimensions\r\n    SVF::SparseVector<double> a = randVec(6);\r\n    svf.pushTimestep(a, a.length());\r\n}\r\n\r\ndouble svfVal = svf.computeSVF();\r\n// This will be between 0 and 1\r\n```\r\n\r\nDocumentation\r\n=====\r\nYeah, right! Read the code and the unit tests.\r\n\r\n\r\nCredits\r\n=====\r\nSVF research is conducted at the Computer Architecture and Security\r\nTechnologies Lab in the Computer Science department at Columbia\r\nUniversity in the city of New York. The original inventors of SVF\r\nare John Demme, Robert Martin, Adam Waksman and Simha Sethumadhavan.\r\nTheir work is/was supported by grants FA 99500910389 (AFOSR), FA\r\n865011C7190 (DARPA), FA 87501020253 (DARPA), CCF/TC 1054844 (NSF)\r\nand gifts from Microsoft Research, WindRiver Corp, Xilinx and\r\nSynopsys Inc. Opinions, findings, conclusions and recommendations\r\nexpressed in this material are those of the authors and do not\r\nnecessarily reflect the views of the US Government or commercial\r\nentities.\r\n\r\nLibSVF code written and occasionally maintained by John Demme\r\n<jdd@cs.columbia.edu>.\r\n","name":"LibSVF","tagline":"A library to compute Side-channel Vulnerability Factor"}